# Візуалізація структури сітки гри

## 🔍 Вигляд "збоку" на мапу

Так, якби ми дивилися збоку на мапу, то побачили б **стеки об'єктів**!

### 📚 Структура кожної клітинки:

```
LinkedList<EntityBase>[y, x]
```

Кожна клітинка сітки містить зв'язаний список (стек) об'єктів:

## 🎯 Приклади стеків в різних клітинках:

### **Клітинка з гравцем (позиція гравця 'C'):**
```
┌─────────────┐
│   Player    │ ← Верх стеку (видимий)
├─────────────┤
│   Space     │ ← Фон (завжди внизу)
└─────────────┘
```

### **Клітинка з привидом (позиція '@'):**
```
┌─────────────┐
│   Ghost     │ ← Верх стеку (видимий)
├─────────────┤
│   Space     │ ← Фон (завжди внизу)
└─────────────┘
```

### **Клітинка зі стіною (позиція '?'):**
```
┌─────────────┐
│   Wall      │ ← Верх стеку (видимий)
├─────────────┤
│   Space     │ ← Фон (завжди внизу)
└─────────────┘
```

### **Клітинка з очком (позиція '.'):**
```
┌─────────────┐
│   Score     │ ← Верх стеку (видимий)
├─────────────┤
│   Space     │ ← Фон (завжди внизу)
└─────────────┘
```

### **Порожня клітинка (позиція ' '):**
```
┌─────────────┐
│   Space     │ ← Тільки фон (видимий)
└─────────────┘
```

## 🏗️ Процес створення стеків:

```csharp
// Для кожної клітинки:
var linkedList = new LinkedList<EntityBase>();
grid[y, x] = linkedList;

// 1. Завжди додається фон
linkedList.AddFirst(new Space());

// 2. Якщо є об'єкт, додається зверху
if (character == 'C')
    linkedList.AddFirst(new Player());  // Player поверх Space
else if (character == '@')
    linkedList.AddFirst(new Ghost());   // Ghost поверх Space
// і т.д.
```

## 🎨 Рендеринг - "Вигляд зверху":

Рендерер дивиться на стеки **зверху** і показує тільки **верхній об'єкт**:

```csharp
var topEntity = grid[y, x].First.Value;  // Бере верхній
Console.Write(topEntity.character);      // Показує його символ
```

## 🚶 Рух об'єктів між стеками:

Коли об'єкт рухається:

### **До руху:**
```
Клітинка A:           Клітинка B:
┌─────────────┐      ┌─────────────┐
│   Player    │      │   Space     │
├─────────────┤      └─────────────┘
│   Space     │
└─────────────┘
```

### **Після руху:**
```
Клітинка A:           Клітинка B:
┌─────────────┐      ┌─────────────┐
│   Space     │      │   Player    │
└─────────────┘      ├─────────────┤
                     │   Space     │
                     └─────────────┘
```

### **Код руху:**
```csharp
public void Move(int x, int y)
{
    // Видаляє з поточного стеку
    scene.grid[this.y, this.x].RemoveFirst();
    
    // Додає в новий стек (зверху!)
    scene.grid[y, x].AddFirst(this);
    
    // Оновлює координати
    this.x = x; this.y = y;
}
```

## 🔄 Складні випадки:

### **Якщо гравець збирає очко:**
```
До збору:                    Після збору:
┌─────────────┐             ┌─────────────┐
│   Player    │             │   Player    │
├─────────────┤      →      ├─────────────┤
│   Score     │             │   Space     │ (Score знищено)
├─────────────┤             └─────────────┘
│   Space     │
└─────────────┘
```

### **Теоретично можливо (але не використовується в грі):**
```
┌─────────────┐
│   Ghost     │ ← Верх (видимий)
├─────────────┤
│   Player    │ ← Прихований
├─────────────┤
│   Score     │ ← Прихований
├─────────────┤
│   Space     │ ← Фон
└─────────────┘
```

## 💡 Переваги такої архітектури:

✅ **Гнучкість** - можна мати кілька об'єктів в одній клітинці  
✅ **Простота** - легко додавати/видаляти об'єкти  
✅ **Ефективність** - швидкий доступ до верхнього об'єкта  
✅ **Розширюваність** - легко додати нові типи взаємодій  

## 🎯 Реальне використання:

В поточній грі кожна клітинка має максимум 2 об'єкти:
1. **Space** (завжди внизу як фон)
2. **Активний об'єкт** зверху (Player, Ghost, Wall, Score)

Але архітектура дозволяє мати **необмежену кількість** об'єктів в стеку!
